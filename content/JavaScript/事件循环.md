---
title: "事件循环"
date: 2025-04-03T07:43:15+08:00
draft: false
tags: ["JavaScript"]
---

## 什么是进程，什么是线程

进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。简单来说，进程就是程序的一次执行实例。当你运行一个程序时，操作系统会为该程序创建一个进程。

线程（Thread）是操作系统能够进行运算调度的最小单位，被包含在进程之中。一个进程可以包含多个线程。线程是程序执行流的最小单元，负责实际的计算工作。

### 进程特点

- 独立的内存空间：每个进程都有自己独立的内存空间，互不干扰
- 拥有系统资源：进程拥有独立的系统资源，如文件句柄、网络连接等
- 相互独立：一个进程的崩溃通常不会影响其他进程
- 通信成本高：进程间通信(IPC)需要特殊的机制，如管道、消息队列等
- 创建和销毁开销大：需要分配和回收系统资源

### 线程特点

- 共享所属进程的内存空间：同一进程内的线程共享进程的内存空间
- 共享进程资源：共享进程的代码段、数据段等资源
- 执行开销小：创建和切换线程的成本远低于进程
- 通信方便：线程间可以直接读写进程的共享数据
- 相互影响：一个线程崩溃可能导致整个进程崩溃

### 进程与线程的关系

- 一个进程至少包含一个线程（主线程）
- 线程是进程中的实际执行单位
- 同一进程中的线程共享进程的资源
- 进程是资源分配的最小单位，线程是 CPU 调度的最小单位

## 事件循环 Event Loop

事件循环是 JavaScript 实现异步的核心机制。JavaScript 是单线程的语言，但通过事件循环实现了非阻塞的异步执行模型。

### 核心概念

1. **调用栈(Call Stack)**

   - JavaScript 代码执行的地方
   - 函数调用形成栈帧
   - 遵循后进先出(LIFO)原则
   - 同一时间只能执行一个任务

2. **堆(Heap)**

   - 存储对象的内存区域
   - 代码运行时分配的内存空间
   - 由垃圾回收器管理

3. **任务队列(Task Queue)**
   - 存储待执行的回调函数
   - 遵循先进先出(FIFO)原则
   - 分为宏任务队列和微任务队列

### 事件循环的执行流程

1. 执行同步代码，同步代码进入调用栈立即执行
2. 遇到异步任务时，将其交给相应的 Web API 处理
3. Web API 处理完成后，将回调函数放入任务队列
4. 当调用栈为空时，事件循环检查任务队列
5. 将任务队列中的任务按顺序放入调用栈执行
6. 重复以上步骤

### 任务类型

#### 宏任务(MacroTask)

宏任务是由标准 JavaScript 引擎机制提供的任务，它们会被放入消息队列中等待主线程执行。当一个宏任务执行时：

- V8 引擎会建立新的执行栈来存储任务
- 执行不同的函数调用时栈会随之变化
- 当该宏任务执行结束时，会清空当前的栈

常见的宏任务包括：

- script(整体代码): JavaScript 脚本的初始化执行属于第一个宏任务
- 事件回调
- setTimeout/setInterval 回调
- setImmediate(Node.js 环境)
- requestAnimationFrame (浏览器环境)
- I/O 操作
- UI 渲染
- DOM 事件

#### 微任务(MicroTask)

微任务是一种需要异步执行的任务，它的执行时机是在当前宏任务结束之后，下一个宏任务开始之前。

- Promise.then/catch/finally
- process.nextTick(Node.js 环境)
- MutationObserver 回调
- queueMicrotask()

### 执行优先级

1. 同步代码优先执行
1. 执行当前的宏任务
1. 执行当前宏任务产生的所有微任务
1. 如果微任务执行过程中产生新的微任务，继续执行完所有微任务
1. 当前宏任务结束，微任务队列清空
1. 开始下一个宏任务
1. 每个宏任务之间可能会进行 UI 渲染

### 示例代码

1. 执行第一个宏任务：script(整体代码)
2. 执行过程中同步代码直接执行
3. 遇到微任务添加到微任务队列
4. 遇到宏任务添加到宏任务队列
5. 当前宏任务执行完毕后，立即执行所有微任务
6. 微任务执行完毕后，开始下一个宏任务

```javascript
// 这是第一个宏任务：script(整体代码)
console.log("script start"); // 同步代码

setTimeout(() => {
  console.log("setTimeout"); // 宏任务
}, 0);

Promise.resolve()
  .then(() => {
    console.log("promise1"); // 微任务
  })
  .then(() => {
    console.log("promise2"); // 微任务
  });

console.log("script end"); // 同步代码
```

### 注意事项

- JavaScript 是单线程语言，但浏览器是多线程的
- 事件循环确保了异步操作不会阻塞主线程
- 微任务优先级高于宏任务
- 过多的同步操作或长时间运行的任务会阻塞 UI 渲染
- Node.js 的事件循环与浏览器有所不同

#### 为什么需要区分宏任务和微任务？

这是 JavaScript 在语言设计上对实时性和效率的权衡：

- 当宏任务执行时间过长时，会影响后续任务的执行
- 某些任务需要在下一轮事件循环之前完成，以提高实时性
- 微任务提供了一种在当前宏任务结束之前执行异步代码的机制
- 有助于控制代码执行顺序，优化性能
